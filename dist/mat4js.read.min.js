let mat4js; (()=>{
  'use strict'; const t={591: (t, e, a)=>{
    const n={}; (0, a(236).assign)(n, a(555), a(843), a(619)), t.exports=n;
  }, 555: (t, e, a)=>{
    const n=a(405); const r=a(236); const i=a(373); const s=a(898); const o=a(292); const h=Object.prototype.toString; function l(t) {
      if (!(this instanceof l)) return new l(t); this.options=r.assign({level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: ''}, t||{}); const e=this.options; e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16), this.err=0, this.msg='', this.ended=!1, this.chunks=[], this.strm=new o, this.strm.avail_out=0; let a=n.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (0!==a) throw new Error(s[a]); if (e.header&&n.deflateSetHeader(this.strm, e.header), e.dictionary) {
        let d; if (d='string'==typeof e.dictionary?i.string2buf(e.dictionary):'[object ArrayBuffer]'===h.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary, 0!==(a=n.deflateSetDictionary(this.strm, d))) throw new Error(s[a]); this._dict_set=!0;
      }
    } function d(t, e) {
      const a=new l(e); if (a.push(t, !0), a.err) throw a.msg||s[a.err]; return a.result;
    }l.prototype.push=function(t, e) {
      let a; let s; const o=this.strm; const l=this.options.chunkSize; if (this.ended) return !1; s=e===~~e?e:!0===e?4:0, 'string'==typeof t?o.input=i.string2buf(t):'[object ArrayBuffer]'===h.call(t)?o.input=new Uint8Array(t):o.input=t, o.next_in=0, o.avail_in=o.input.length; do {
        if (0===o.avail_out&&(o.output=new r.Buf8(l), o.next_out=0, o.avail_out=l), 1!==(a=n.deflate(o, s))&&0!==a) return this.onEnd(a), this.ended=!0, !1; 0!==o.avail_out&&(0!==o.avail_in||4!==s&&2!==s)||('string'===this.options.to?this.onData(i.buf2binstring(r.shrinkBuf(o.output, o.next_out))):this.onData(r.shrinkBuf(o.output, o.next_out)));
      } while ((o.avail_in>0||0===o.avail_out)&&1!==a); return 4===s?(a=n.deflateEnd(this.strm), this.onEnd(a), this.ended=!0, 0===a):2!==s||(this.onEnd(0), o.avail_out=0, !0);
    }, l.prototype.onData=function(t) {
      this.chunks.push(t);
    }, l.prototype.onEnd=function(t) {
      0===t&&('string'===this.options.to?this.result=this.chunks.join(''):this.result=r.flattenChunks(this.chunks)), this.chunks=[], this.err=t, this.msg=this.strm.msg;
    }, e.Deflate=l, e.deflate=d, e.deflateRaw=function(t, e) {
      return (e=e||{}).raw=!0, d(t, e);
    }, e.gzip=function(t, e) {
      return (e=e||{}).gzip=!0, d(t, e);
    };
  }, 843: (t, e, a)=>{
    const n=a(948); const r=a(236); const i=a(373); const s=a(619); const o=a(898); const h=a(292); const l=a(401); const d=Object.prototype.toString; function f(t) {
      if (!(this instanceof f)) return new f(t); this.options=r.assign({chunkSize: 16384, windowBits: 0, to: ''}, t||{}); const e=this.options; e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits, 0===e.windowBits&&(e.windowBits=-15)), !(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32), e.windowBits>15&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15), this.err=0, this.msg='', this.ended=!1, this.chunks=[], this.strm=new h, this.strm.avail_out=0; let a=n.inflateInit2(this.strm, e.windowBits); if (a!==s.Z_OK) throw new Error(o[a]); if (this.header=new l, n.inflateGetHeader(this.strm, this.header), e.dictionary&&('string'==typeof e.dictionary?e.dictionary=i.string2buf(e.dictionary):'[object ArrayBuffer]'===d.call(e.dictionary)&&(e.dictionary=new Uint8Array(e.dictionary)), e.raw&&(a=n.inflateSetDictionary(this.strm, e.dictionary))!==s.Z_OK)) throw new Error(o[a]);
    } function _(t, e) {
      const a=new f(e); if (a.push(t, !0), a.err) throw a.msg||o[a.err]; return a.result;
    }f.prototype.push=function(t, e) {
      let a; let o; let h; let l; let f; const _=this.strm; const u=this.options.chunkSize; const c=this.options.dictionary; let g=!1; if (this.ended) return !1; o=e===~~e?e:!0===e?s.Z_FINISH:s.Z_NO_FLUSH, 'string'==typeof t?_.input=i.binstring2buf(t):'[object ArrayBuffer]'===d.call(t)?_.input=new Uint8Array(t):_.input=t, _.next_in=0, _.avail_in=_.input.length; do {
        if (0===_.avail_out&&(_.output=new r.Buf8(u), _.next_out=0, _.avail_out=u), (a=n.inflate(_, s.Z_NO_FLUSH))===s.Z_NEED_DICT&&c&&(a=n.inflateSetDictionary(this.strm, c)), a===s.Z_BUF_ERROR&&!0===g&&(a=s.Z_OK, g=!1), a!==s.Z_STREAM_END&&a!==s.Z_OK) return this.onEnd(a), this.ended=!0, !1; _.next_out&&(0!==_.avail_out&&a!==s.Z_STREAM_END&&(0!==_.avail_in||o!==s.Z_FINISH&&o!==s.Z_SYNC_FLUSH)||('string'===this.options.to?(h=i.utf8border(_.output, _.next_out), l=_.next_out-h, f=i.buf2string(_.output, h), _.next_out=l, _.avail_out=u-l, l&&r.arraySet(_.output, _.output, h, l, 0), this.onData(f)):this.onData(r.shrinkBuf(_.output, _.next_out)))), 0===_.avail_in&&0===_.avail_out&&(g=!0);
      } while ((_.avail_in>0||0===_.avail_out)&&a!==s.Z_STREAM_END); return a===s.Z_STREAM_END&&(o=s.Z_FINISH), o===s.Z_FINISH?(a=n.inflateEnd(this.strm), this.onEnd(a), this.ended=!0, a===s.Z_OK):o!==s.Z_SYNC_FLUSH||(this.onEnd(s.Z_OK), _.avail_out=0, !0);
    }, f.prototype.onData=function(t) {
      this.chunks.push(t);
    }, f.prototype.onEnd=function(t) {
      t===s.Z_OK&&('string'===this.options.to?this.result=this.chunks.join(''):this.result=r.flattenChunks(this.chunks)), this.chunks=[], this.err=t, this.msg=this.strm.msg;
    }, e.Inflate=f, e.inflate=_, e.inflateRaw=function(t, e) {
      return (e=e||{}).raw=!0, _(t, e);
    }, e.ungzip=_;
  }, 236: (t, e)=>{
    const a='undefined'!=typeof Uint8Array&&'undefined'!=typeof Uint16Array&&'undefined'!=typeof Int32Array; function n(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }e.assign=function(t) {
      for (let e=Array.prototype.slice.call(arguments, 1); e.length;) {
        const a=e.shift(); if (a) {
          if ('object'!=typeof a) throw new TypeError(a+'must be non-object'); for (const r in a)n(a, r)&&(t[r]=a[r]);
        }
      } return t;
    }, e.shrinkBuf=function(t, e) {
      return t.length===e?t:t.subarray?t.subarray(0, e):(t.length=e, t);
    }; const r={arraySet: function(t, e, a, n, r) {
      if (e.subarray&&t.subarray)t.set(e.subarray(a, a+n), r); else for (let i=0; i<n; i++)t[r+i]=e[a+i];
    }, flattenChunks: function(t) {
      let e; let a; let n; let r; let i; let s; for (n=0, e=0, a=t.length; e<a; e++)n+=t[e].length; for (s=new Uint8Array(n), r=0, e=0, a=t.length; e<a; e++)i=t[e], s.set(i, r), r+=i.length; return s;
    }}; const i={arraySet: function(t, e, a, n, r) {
      for (let i=0; i<n; i++)t[r+i]=e[a+i];
    }, flattenChunks: function(t) {
      return [].concat.apply([], t);
    }}; e.setTyped=function(t) {
t?(e.Buf8=Uint8Array, e.Buf16=Uint16Array, e.Buf32=Int32Array, e.assign(e, r)):(e.Buf8=Array, e.Buf16=Array, e.Buf32=Array, e.assign(e, i));
    }, e.setTyped(a);
  }, 373: (t, e, a)=>{
    const n=a(236); let r=!0; let i=!0; try {
      String.fromCharCode.apply(null, [0]);
    } catch (t) {
      r=!1;
    } try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (t) {
      i=!1;
    } for (var s=new n.Buf8(256), o=0; o<256; o++)s[o]=o>=252?6:o>=248?5:o>=240?4:o>=224?3:o>=192?2:1; function h(t, e) {
      if (e<65534&&(t.subarray&&i||!t.subarray&&r)) return String.fromCharCode.apply(null, n.shrinkBuf(t, e)); for (var a='', s=0; s<e; s++)a+=String.fromCharCode(t[s]); return a;
    }s[254]=s[254]=1, e.string2buf=function(t) {
      let e; let a; let r; let i; let s; const o=t.length; let h=0; for (i=0; i<o; i++)55296==(64512&(a=t.charCodeAt(i)))&&i+1<o&&56320==(64512&(r=t.charCodeAt(i+1)))&&(a=65536+(a-55296<<10)+(r-56320), i++), h+=a<128?1:a<2048?2:a<65536?3:4; for (e=new n.Buf8(h), s=0, i=0; s<h; i++)55296==(64512&(a=t.charCodeAt(i)))&&i+1<o&&56320==(64512&(r=t.charCodeAt(i+1)))&&(a=65536+(a-55296<<10)+(r-56320), i++), a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6, e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12, e[s++]=128|a>>>6&63, e[s++]=128|63&a):(e[s++]=240|a>>>18, e[s++]=128|a>>>12&63, e[s++]=128|a>>>6&63, e[s++]=128|63&a); return e;
    }, e.buf2binstring=function(t) {
      return h(t, t.length);
    }, e.binstring2buf=function(t) {
      for (var e=new n.Buf8(t.length), a=0, r=e.length; a<r; a++)e[a]=t.charCodeAt(a); return e;
    }, e.buf2string=function(t, e) {
      let a; let n; let r; let i; const o=e||t.length; const l=new Array(2*o); for (n=0, a=0; a<o;) {
        if ((r=t[a++])<128)l[n++]=r; else if ((i=s[r])>4)l[n++]=65533, a+=i-1; else {
          for (r&=2===i?31:3===i?15:7; i>1&&a<o;)r=r<<6|63&t[a++], i--; i>1?l[n++]=65533:r<65536?l[n++]=r:(r-=65536, l[n++]=55296|r>>10&1023, l[n++]=56320|1023&r);
        }
      } return h(l, n);
    }, e.utf8border=function(t, e) {
      let a; for ((e=e||t.length)>t.length&&(e=t.length), a=e-1; a>=0&&128==(192&t[a]);)a--; return a<0||0===a?e:a+s[t[a]]>e?a:e;
    };
  }, 69: (t)=>{
    t.exports=function(t, e, a, n) {
      for (var r=65535&t|0, i=t>>>16&65535|0, s=0; 0!==a;) {
        a-=s=a>2e3?2e3:a; do {
          i=i+(r=r+e[n++]|0)|0;
        } while (--s); r%=65521, i%=65521;
      } return r|i<<16|0;
    };
  }, 619: (t)=>{
    t.exports={Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8};
  }, 869: (t)=>{
    const e=function() {
      for (var t, e=[], a=0; a<256; a++) {
        t=a; for (let n=0; n<8; n++)t=1&t?3988292384^t>>>1:t>>>1; e[a]=t;
      } return e;
    }(); t.exports=function(t, a, n, r) {
      const i=e; const s=r+n; t^=-1; for (let o=r; o<s; o++)t=t>>>8^i[255&(t^a[o])]; return -1^t;
    };
  }, 405: (t, e, a)=>{
    let n; const r=a(236); const i=a(342); const s=a(69); const o=a(869); const h=a(898); const l=-2; const d=258; const f=262; const _=103; const u=113; const c=666; function g(t, e) {
      return t.msg=h[e], e;
    } function w(t) {
      return (t<<1)-(t>4?9:0);
    } function p(t) {
      for (let e=t.length; --e>=0;)t[e]=0;
    } function b(t) {
      const e=t.state; let a=e.pending; a>t.avail_out&&(a=t.avail_out), 0!==a&&(r.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out+=a, e.pending_out+=a, t.total_out+=a, t.avail_out-=a, e.pending-=a, 0===e.pending&&(e.pending_out=0));
    } function m(t, e) {
      i._tr_flush_block(t, t.block_start>=0?t.block_start:-1, t.strstart-t.block_start, e), t.block_start=t.strstart, b(t.strm);
    } function v(t, e) {
      t.pending_buf[t.pending++]=e;
    } function k(t, e) {
      t.pending_buf[t.pending++]=e>>>8&255, t.pending_buf[t.pending++]=255&e;
    } function y(t, e) {
      let a; let n; let r=t.max_chain_length; let i=t.strstart; let s=t.prev_length; let o=t.nice_match; const h=t.strstart>t.w_size-f?t.strstart-(t.w_size-f):0; const l=t.window; const _=t.w_mask; const u=t.prev; const c=t.strstart+d; let g=l[i+s-1]; let w=l[i+s]; t.prev_length>=t.good_match&&(r>>=2), o>t.lookahead&&(o=t.lookahead); do {
        if (l[(a=e)+s]===w&&l[a+s-1]===g&&l[a]===l[i]&&l[++a]===l[i+1]) {
          i+=2, a++; do {} while (l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&i<c); if (n=d-(c-i), i=c-d, n>s) {
            if (t.match_start=e, s=n, n>=o) break; g=l[i+s-1], w=l[i+s];
          }
        }
      } while ((e=u[e&_])>h&&0!=--r); return s<=t.lookahead?s:t.lookahead;
    } function x(t) {
      let e; let a; let n; let i; let h; let l; let d; let _; let u; let c; const g=t.w_size; do {
        if (i=t.window_size-t.lookahead-t.strstart, t.strstart>=g+(g-f)) {
          r.arraySet(t.window, t.window, g, g, 0), t.match_start-=g, t.strstart-=g, t.block_start-=g, e=a=t.hash_size; do {
            n=t.head[--e], t.head[e]=n>=g?n-g:0;
          } while (--a); e=a=g; do {
            n=t.prev[--e], t.prev[e]=n>=g?n-g:0;
          } while (--a); i+=g;
        } if (0===t.strm.avail_in) break; if (l=t.strm, d=t.window, _=t.strstart+t.lookahead, u=i, c=void 0, (c=l.avail_in)>u&&(c=u), a=0===c?0:(l.avail_in-=c, r.arraySet(d, l.input, l.next_in, c, _), 1===l.state.wrap?l.adler=s(l.adler, d, c, _):2===l.state.wrap&&(l.adler=o(l.adler, d, c, _)), l.next_in+=c, l.total_in+=c, c), t.lookahead+=a, t.lookahead+t.insert>=3) for (h=t.strstart-t.insert, t.ins_h=t.window[h], t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+1])&t.hash_mask; t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[h+3-1])&t.hash_mask, t.prev[h&t.w_mask]=t.head[t.ins_h], t.head[t.ins_h]=h, h++, t.insert--, !(t.lookahead+t.insert<3)););
      } while (t.lookahead<f&&0!==t.strm.avail_in);
    } function z(t, e) {
      for (var a, n; ;) {
        if (t.lookahead<f) {
          if (x(t), t.lookahead<f&&0===e) return 1; if (0===t.lookahead) break;
        } if (a=0, t.lookahead>=3&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+3-1])&t.hash_mask, a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h], t.head[t.ins_h]=t.strstart), 0!==a&&t.strstart-a<=t.w_size-f&&(t.match_length=y(t, a)), t.match_length>=3) {
          if (n=i._tr_tally(t, t.strstart-t.match_start, t.match_length-3), t.lookahead-=t.match_length, t.match_length<=t.max_lazy_match&&t.lookahead>=3) {
            t.match_length--; do {
              t.strstart++, t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+3-1])&t.hash_mask, a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h], t.head[t.ins_h]=t.strstart;
            } while (0!=--t.match_length); t.strstart++;
          } else t.strstart+=t.match_length, t.match_length=0, t.ins_h=t.window[t.strstart], t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;
        } else n=i._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (n&&(m(t, !1), 0===t.strm.avail_out)) return 1;
      } return t.insert=t.strstart<2?t.strstart:2, 4===e?(m(t, !0), 0===t.strm.avail_out?3:4):t.last_lit&&(m(t, !1), 0===t.strm.avail_out)?1:2;
    } function S(t, e) {
      for (var a, n, r; ;) {
        if (t.lookahead<f) {
          if (x(t), t.lookahead<f&&0===e) return 1; if (0===t.lookahead) break;
        } if (a=0, t.lookahead>=3&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+3-1])&t.hash_mask, a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h], t.head[t.ins_h]=t.strstart), t.prev_length=t.match_length, t.prev_match=t.match_start, t.match_length=2, 0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-f&&(t.match_length=y(t, a), t.match_length<=5&&(1===t.strategy||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)), t.prev_length>=3&&t.match_length<=t.prev_length) {
          r=t.strstart+t.lookahead-3, n=i._tr_tally(t, t.strstart-1-t.prev_match, t.prev_length-3), t.lookahead-=t.prev_length-1, t.prev_length-=2; do {
            ++t.strstart<=r&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+3-1])&t.hash_mask, a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h], t.head[t.ins_h]=t.strstart);
          } while (0!=--t.prev_length); if (t.match_available=0, t.match_length=2, t.strstart++, n&&(m(t, !1), 0===t.strm.avail_out)) return 1;
        } else if (t.match_available) {
          if ((n=i._tr_tally(t, 0, t.window[t.strstart-1]))&&m(t, !1), t.strstart++, t.lookahead--, 0===t.strm.avail_out) return 1;
        } else t.match_available=1, t.strstart++, t.lookahead--;
      } return t.match_available&&(n=i._tr_tally(t, 0, t.window[t.strstart-1]), t.match_available=0), t.insert=t.strstart<2?t.strstart:2, 4===e?(m(t, !0), 0===t.strm.avail_out?3:4):t.last_lit&&(m(t, !1), 0===t.strm.avail_out)?1:2;
    } function B(t, e, a, n, r) {
      this.good_length=t, this.max_lazy=e, this.nice_length=a, this.max_chain=n, this.func=r;
    } function A() {
      this.strm=null, this.status=0, this.pending_buf=null, this.pending_buf_size=0, this.pending_out=0, this.pending=0, this.wrap=0, this.gzhead=null, this.gzindex=0, this.method=8, this.last_flush=-1, this.w_size=0, this.w_bits=0, this.w_mask=0, this.window=null, this.window_size=0, this.prev=null, this.head=null, this.ins_h=0, this.hash_size=0, this.hash_bits=0, this.hash_mask=0, this.hash_shift=0, this.block_start=0, this.match_length=0, this.prev_match=0, this.match_available=0, this.strstart=0, this.match_start=0, this.lookahead=0, this.prev_length=0, this.max_chain_length=0, this.max_lazy_match=0, this.level=0, this.strategy=0, this.good_match=0, this.nice_match=0, this.dyn_ltree=new r.Buf16(1146), this.dyn_dtree=new r.Buf16(122), this.bl_tree=new r.Buf16(78), p(this.dyn_ltree), p(this.dyn_dtree), p(this.bl_tree), this.l_desc=null, this.d_desc=null, this.bl_desc=null, this.bl_count=new r.Buf16(16), this.heap=new r.Buf16(573), p(this.heap), this.heap_len=0, this.heap_max=0, this.depth=new r.Buf16(573), p(this.depth), this.l_buf=0, this.lit_bufsize=0, this.last_lit=0, this.d_buf=0, this.opt_len=0, this.static_len=0, this.matches=0, this.insert=0, this.bi_buf=0, this.bi_valid=0;
    } function E(t) {
      let e; return t&&t.state?(t.total_in=t.total_out=0, t.data_type=2, (e=t.state).pending=0, e.pending_out=0, e.wrap<0&&(e.wrap=-e.wrap), e.status=e.wrap?42:u, t.adler=2===e.wrap?0:1, e.last_flush=0, i._tr_init(e), 0):g(t, l);
    } function I(t) {
      let e; const a=E(t); return 0===a&&((e=t.state).window_size=2*e.w_size, p(e.head), e.max_lazy_match=n[e.level].max_lazy, e.good_match=n[e.level].good_length, e.nice_match=n[e.level].nice_length, e.max_chain_length=n[e.level].max_chain, e.strstart=0, e.block_start=0, e.lookahead=0, e.insert=0, e.match_length=e.prev_length=2, e.match_available=0, e.ins_h=0), a;
    } function Z(t, e, a, n, i, s) {
      if (!t) return l; let o=1; if (-1===e&&(e=6), n<0?(o=0, n=-n):n>15&&(o=2, n-=16), i<1||i>9||8!==a||n<8||n>15||e<0||e>9||s<0||s>4) return g(t, l); 8===n&&(n=9); const h=new A; return t.state=h, h.strm=t, h.wrap=o, h.gzhead=null, h.w_bits=n, h.w_size=1<<h.w_bits, h.w_mask=h.w_size-1, h.hash_bits=i+7, h.hash_size=1<<h.hash_bits, h.hash_mask=h.hash_size-1, h.hash_shift=~~((h.hash_bits+3-1)/3), h.window=new r.Buf8(2*h.w_size), h.head=new r.Buf16(h.hash_size), h.prev=new r.Buf16(h.w_size), h.lit_bufsize=1<<i+6, h.pending_buf_size=4*h.lit_bufsize, h.pending_buf=new r.Buf8(h.pending_buf_size), h.d_buf=1*h.lit_bufsize, h.l_buf=3*h.lit_bufsize, h.level=e, h.strategy=s, h.method=a, I(t);
    }n=[new B(0, 0, 0, 0, (function(t, e) {
      let a=65535; for (a>t.pending_buf_size-5&&(a=t.pending_buf_size-5); ;) {
        if (t.lookahead<=1) {
          if (x(t), 0===t.lookahead&&0===e) return 1; if (0===t.lookahead) break;
        }t.strstart+=t.lookahead, t.lookahead=0; const n=t.block_start+a; if ((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n, t.strstart=n, m(t, !1), 0===t.strm.avail_out)) return 1; if (t.strstart-t.block_start>=t.w_size-f&&(m(t, !1), 0===t.strm.avail_out)) return 1;
      } return t.insert=0, 4===e?(m(t, !0), 0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(m(t, !1), t.strm.avail_out), 1);
    })), new B(4, 4, 8, 4, z), new B(4, 5, 16, 8, z), new B(4, 6, 32, 32, z), new B(4, 4, 16, 16, S), new B(8, 16, 32, 32, S), new B(8, 16, 128, 128, S), new B(8, 32, 128, 256, S), new B(32, 128, 258, 1024, S), new B(32, 258, 258, 4096, S)], e.deflateInit=function(t, e) {
      return Z(t, e, 8, 15, 8, 0);
    }, e.deflateInit2=Z, e.deflateReset=I, e.deflateResetKeep=E, e.deflateSetHeader=function(t, e) {
      return t&&t.state?2!==t.state.wrap?l:(t.state.gzhead=e, 0):l;
    }, e.deflate=function(t, e) {
      let a; let r; let s; let h; if (!t||!t.state||e>5||e<0) return t?g(t, l):l; if (r=t.state, !t.output||!t.input&&0!==t.avail_in||r.status===c&&4!==e) return g(t, 0===t.avail_out?-5:l); if (r.strm=t, a=r.last_flush, r.last_flush=e, 42===r.status) {
        if (2===r.wrap)t.adler=0, v(r, 31), v(r, 139), v(r, 8), r.gzhead?(v(r, (r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)), v(r, 255&r.gzhead.time), v(r, r.gzhead.time>>8&255), v(r, r.gzhead.time>>16&255), v(r, r.gzhead.time>>24&255), v(r, 9===r.level?2:r.strategy>=2||r.level<2?4:0), v(r, 255&r.gzhead.os), r.gzhead.extra&&r.gzhead.extra.length&&(v(r, 255&r.gzhead.extra.length), v(r, r.gzhead.extra.length>>8&255)), r.gzhead.hcrc&&(t.adler=o(t.adler, r.pending_buf, r.pending, 0)), r.gzindex=0, r.status=69):(v(r, 0), v(r, 0), v(r, 0), v(r, 0), v(r, 0), v(r, 9===r.level?2:r.strategy>=2||r.level<2?4:0), v(r, 3), r.status=u); else {
          let f=8+(r.w_bits-8<<4)<<8; f|=(r.strategy>=2||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6, 0!==r.strstart&&(f|=32), f+=31-f%31, r.status=u, k(r, f), 0!==r.strstart&&(k(r, t.adler>>>16), k(r, 65535&t.adler)), t.adler=1;
        }
      } if (69===r.status) {
        if (r.gzhead.extra) {
          for (s=r.pending; r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), b(t), s=r.pending, r.pending!==r.pending_buf_size));)v(r, 255&r.gzhead.extra[r.gzindex]), r.gzindex++; r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), r.gzindex===r.gzhead.extra.length&&(r.gzindex=0, r.status=73);
        } else r.status=73;
      } if (73===r.status) {
        if (r.gzhead.name) {
          s=r.pending; do {
            if (r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), b(t), s=r.pending, r.pending===r.pending_buf_size)) {
              h=1; break;
            }h=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0, v(r, h);
          } while (0!==h); r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), 0===h&&(r.gzindex=0, r.status=91);
        } else r.status=91;
      } if (91===r.status) {
        if (r.gzhead.comment) {
          s=r.pending; do {
            if (r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), b(t), s=r.pending, r.pending===r.pending_buf_size)) {
              h=1; break;
            }h=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0, v(r, h);
          } while (0!==h); r.gzhead.hcrc&&r.pending>s&&(t.adler=o(t.adler, r.pending_buf, r.pending-s, s)), 0===h&&(r.status=_);
        } else r.status=_;
      } if (r.status===_&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&b(t), r.pending+2<=r.pending_buf_size&&(v(r, 255&t.adler), v(r, t.adler>>8&255), t.adler=0, r.status=u)):r.status=u), 0!==r.pending) {
        if (b(t), 0===t.avail_out) return r.last_flush=-1, 0;
      } else if (0===t.avail_in&&w(e)<=w(a)&&4!==e) return g(t, -5); if (r.status===c&&0!==t.avail_in) return g(t, -5); if (0!==t.avail_in||0!==r.lookahead||0!==e&&r.status!==c) {
        const y=2===r.strategy?function(t, e) {
          for (var a; ;) {
            if (0===t.lookahead&&(x(t), 0===t.lookahead)) {
              if (0===e) return 1; break;
            } if (t.match_length=0, a=i._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a&&(m(t, !1), 0===t.strm.avail_out)) return 1;
          } return t.insert=0, 4===e?(m(t, !0), 0===t.strm.avail_out?3:4):t.last_lit&&(m(t, !1), 0===t.strm.avail_out)?1:2;
        }(r, e):3===r.strategy?function(t, e) {
          for (var a, n, r, s, o=t.window; ;) {
            if (t.lookahead<=d) {
              if (x(t), t.lookahead<=d&&0===e) return 1; if (0===t.lookahead) break;
            } if (t.match_length=0, t.lookahead>=3&&t.strstart>0&&(n=o[r=t.strstart-1])===o[++r]&&n===o[++r]&&n===o[++r]) {
              s=t.strstart+d; do {} while (n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&r<s); t.match_length=d-(s-r), t.match_length>t.lookahead&&(t.match_length=t.lookahead);
            } if (t.match_length>=3?(a=i._tr_tally(t, 1, t.match_length-3), t.lookahead-=t.match_length, t.strstart+=t.match_length, t.match_length=0):(a=i._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a&&(m(t, !1), 0===t.strm.avail_out)) return 1;
          } return t.insert=0, 4===e?(m(t, !0), 0===t.strm.avail_out?3:4):t.last_lit&&(m(t, !1), 0===t.strm.avail_out)?1:2;
        }(r, e):n[r.level].func(r, e); if (3!==y&&4!==y||(r.status=c), 1===y||3===y) return 0===t.avail_out&&(r.last_flush=-1), 0; if (2===y&&(1===e?i._tr_align(r):5!==e&&(i._tr_stored_block(r, 0, 0, !1), 3===e&&(p(r.head), 0===r.lookahead&&(r.strstart=0, r.block_start=0, r.insert=0))), b(t), 0===t.avail_out)) return r.last_flush=-1, 0;
      } return 4!==e?0:r.wrap<=0?1:(2===r.wrap?(v(r, 255&t.adler), v(r, t.adler>>8&255), v(r, t.adler>>16&255), v(r, t.adler>>24&255), v(r, 255&t.total_in), v(r, t.total_in>>8&255), v(r, t.total_in>>16&255), v(r, t.total_in>>24&255)):(k(r, t.adler>>>16), k(r, 65535&t.adler)), b(t), r.wrap>0&&(r.wrap=-r.wrap), 0!==r.pending?0:1);
    }, e.deflateEnd=function(t) {
      let e; return t&&t.state?42!==(e=t.state.status)&&69!==e&&73!==e&&91!==e&&e!==_&&e!==u&&e!==c?g(t, l):(t.state=null, e===u?g(t, -3):0):l;
    }, e.deflateSetDictionary=function(t, e) {
      let a; let n; let i; let o; let h; let d; let f; let _; let u=e.length; if (!t||!t.state) return l; if (2===(o=(a=t.state).wrap)||1===o&&42!==a.status||a.lookahead) return l; for (1===o&&(t.adler=s(t.adler, e, u, 0)), a.wrap=0, u>=a.w_size&&(0===o&&(p(a.head), a.strstart=0, a.block_start=0, a.insert=0), _=new r.Buf8(a.w_size), r.arraySet(_, e, u-a.w_size, a.w_size, 0), e=_, u=a.w_size), h=t.avail_in, d=t.next_in, f=t.input, t.avail_in=u, t.next_in=0, t.input=e, x(a); a.lookahead>=3;) {
        n=a.strstart, i=a.lookahead-2; do {
          a.ins_h=(a.ins_h<<a.hash_shift^a.window[n+3-1])&a.hash_mask, a.prev[n&a.w_mask]=a.head[a.ins_h], a.head[a.ins_h]=n, n++;
        } while (--i); a.strstart=n, a.lookahead=2, x(a);
      } return a.strstart+=a.lookahead, a.block_start=a.strstart, a.insert=a.lookahead, a.lookahead=0, a.match_length=a.prev_length=2, a.match_available=0, t.next_in=d, t.input=f, t.avail_in=h, a.wrap=o, 0;
    }, e.deflateInfo='pako deflate (from Nodeca project)';
  }, 401: (t)=>{
    t.exports=function() {
      this.text=0, this.time=0, this.xflags=0, this.os=0, this.extra=null, this.extra_len=0, this.name='', this.comment='', this.hcrc=0, this.done=!1;
    };
  }, 264: (t)=>{
    t.exports=function(t, e) {
      let a; let n; let r; let i; let s; let o; let h; let l; let d; let f; let _; let u; let c; let g; let w; let p; let b; let m; let v; let k; let y; let x; let z; let S; let B; a=t.state, n=t.next_in, S=t.input, r=n+(t.avail_in-5), i=t.next_out, B=t.output, s=i-(e-t.avail_out), o=i+(t.avail_out-257), h=a.dmax, l=a.wsize, d=a.whave, f=a.wnext, _=a.window, u=a.hold, c=a.bits, g=a.lencode, w=a.distcode, p=(1<<a.lenbits)-1, b=(1<<a.distbits)-1; t:do {
        c<15&&(u+=S[n++]<<c, c+=8, u+=S[n++]<<c, c+=8), m=g[u&p]; e:for (;;) {
          if (u>>>=v=m>>>24, c-=v, 0==(v=m>>>16&255))B[i++]=65535&m; else {
            if (!(16&v)) {
              if (0==(64&v)) {
                m=g[(65535&m)+(u&(1<<v)-1)]; continue e;
              } if (32&v) {
                a.mode=12; break t;
              }t.msg='invalid literal/length code', a.mode=30; break t;
            }k=65535&m, (v&=15)&&(c<v&&(u+=S[n++]<<c, c+=8), k+=u&(1<<v)-1, u>>>=v, c-=v), c<15&&(u+=S[n++]<<c, c+=8, u+=S[n++]<<c, c+=8), m=w[u&b]; a:for (;;) {
              if (u>>>=v=m>>>24, c-=v, !(16&(v=m>>>16&255))) {
                if (0==(64&v)) {
                  m=w[(65535&m)+(u&(1<<v)-1)]; continue a;
                }t.msg='invalid distance code', a.mode=30; break t;
              } if (y=65535&m, c<(v&=15)&&(u+=S[n++]<<c, (c+=8)<v&&(u+=S[n++]<<c, c+=8)), (y+=u&(1<<v)-1)>h) {
                t.msg='invalid distance too far back', a.mode=30; break t;
              } if (u>>>=v, c-=v, y>(v=i-s)) {
                if ((v=y-v)>d&&a.sane) {
                  t.msg='invalid distance too far back', a.mode=30; break t;
                } if (x=0, z=_, 0===f) {
                  if (x+=l-v, v<k) {
                    k-=v; do {
                      B[i++]=_[x++];
                    } while (--v); x=i-y, z=B;
                  }
                } else if (f<v) {
                  if (x+=l+f-v, (v-=f)<k) {
                    k-=v; do {
                      B[i++]=_[x++];
                    } while (--v); if (x=0, f<k) {
                      k-=v=f; do {
                        B[i++]=_[x++];
                      } while (--v); x=i-y, z=B;
                    }
                  }
                } else if (x+=f-v, v<k) {
                  k-=v; do {
                    B[i++]=_[x++];
                  } while (--v); x=i-y, z=B;
                } for (;k>2;)B[i++]=z[x++], B[i++]=z[x++], B[i++]=z[x++], k-=3; k&&(B[i++]=z[x++], k>1&&(B[i++]=z[x++]));
              } else {
                x=i-y; do {
                  B[i++]=B[x++], B[i++]=B[x++], B[i++]=B[x++], k-=3;
                } while (k>2); k&&(B[i++]=B[x++], k>1&&(B[i++]=B[x++]));
              } break;
            }
          } break;
        }
      } while (n<r&&i<o); n-=k=c>>3, u&=(1<<(c-=k<<3))-1, t.next_in=n, t.next_out=i, t.avail_in=n<r?r-n+5:5-(n-r), t.avail_out=i<o?o-i+257:257-(i-o), a.hold=u, a.bits=c;
    };
  }, 948: (t, e, a)=>{
    const n=a(236); const r=a(69); const i=a(869); const s=a(264); const o=a(241); const h=-2; const l=12; const d=30; function f(t) {
      return (t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24);
    } function _() {
      this.mode=0, this.last=!1, this.wrap=0, this.havedict=!1, this.flags=0, this.dmax=0, this.check=0, this.total=0, this.head=null, this.wbits=0, this.wsize=0, this.whave=0, this.wnext=0, this.window=null, this.hold=0, this.bits=0, this.length=0, this.offset=0, this.extra=0, this.lencode=null, this.distcode=null, this.lenbits=0, this.distbits=0, this.ncode=0, this.nlen=0, this.ndist=0, this.have=0, this.next=null, this.lens=new n.Buf16(320), this.work=new n.Buf16(288), this.lendyn=null, this.distdyn=null, this.sane=0, this.back=0, this.was=0;
    } function u(t) {
      let e; return t&&t.state?(e=t.state, t.total_in=t.total_out=e.total=0, t.msg='', e.wrap&&(t.adler=1&e.wrap), e.mode=1, e.last=0, e.havedict=0, e.dmax=32768, e.head=null, e.hold=0, e.bits=0, e.lencode=e.lendyn=new n.Buf32(852), e.distcode=e.distdyn=new n.Buf32(592), e.sane=1, e.back=-1, 0):h;
    } function c(t) {
      let e; return t&&t.state?((e=t.state).wsize=0, e.whave=0, e.wnext=0, u(t)):h;
    } function g(t, e) {
      let a; let n; return t&&t.state?(n=t.state, e<0?(a=0, e=-e):(a=1+(e>>4), e<48&&(e&=15)), e&&(e<8||e>15)?h:(null!==n.window&&n.wbits!==e&&(n.window=null), n.wrap=a, n.wbits=e, c(t))):h;
    } function w(t, e) {
      let a; let n; return t?(n=new _, t.state=n, n.window=null, 0!==(a=g(t, e))&&(t.state=null), a):h;
    } let p; let b; let m=!0; function v(t) {
      if (m) {
        let e; for (p=new n.Buf32(512), b=new n.Buf32(32), e=0; e<144;)t.lens[e++]=8; for (;e<256;)t.lens[e++]=9; for (;e<280;)t.lens[e++]=7; for (;e<288;)t.lens[e++]=8; for (o(1, t.lens, 0, 288, p, 0, t.work, {bits: 9}), e=0; e<32;)t.lens[e++]=5; o(2, t.lens, 0, 32, b, 0, t.work, {bits: 5}), m=!1;
      }t.lencode=p, t.lenbits=9, t.distcode=b, t.distbits=5;
    } function k(t, e, a, r) {
      let i; const s=t.state; return null===s.window&&(s.wsize=1<<s.wbits, s.wnext=0, s.whave=0, s.window=new n.Buf8(s.wsize)), r>=s.wsize?(n.arraySet(s.window, e, a-s.wsize, s.wsize, 0), s.wnext=0, s.whave=s.wsize):((i=s.wsize-s.wnext)>r&&(i=r), n.arraySet(s.window, e, a-r, i, s.wnext), (r-=i)?(n.arraySet(s.window, e, a-r, r, 0), s.wnext=r, s.whave=s.wsize):(s.wnext+=i, s.wnext===s.wsize&&(s.wnext=0), s.whave<s.wsize&&(s.whave+=i))), 0;
    }e.inflateReset=c, e.inflateReset2=g, e.inflateResetKeep=u, e.inflateInit=function(t) {
      return w(t, 15);
    }, e.inflateInit2=w, e.inflate=function(t, e) {
      let a; let _; let u; let c; let g; let w; let p; let b; let m; let y; let x; let z; let S; let B; let A; let E; let I; let Z; let C; let D; let O; let T; let N; let R; let U=0; const F=new n.Buf8(4); const L=[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!t||!t.state||!t.output||!t.input&&0!==t.avail_in) return h; (a=t.state).mode===l&&(a.mode=13), g=t.next_out, u=t.output, p=t.avail_out, c=t.next_in, _=t.input, w=t.avail_in, b=a.hold, m=a.bits, y=w, x=p, T=0; t:for (;;) {
        switch (a.mode) {
          case 1: if (0===a.wrap) {
            a.mode=13; break;
          } for (;m<16;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } if (2&a.wrap&&35615===b) {
              a.check=0, F[0]=255&b, F[1]=b>>>8&255, a.check=i(a.check, F, 2, 0), b=0, m=0, a.mode=2; break;
            } if (a.flags=0, a.head&&(a.head.done=!1), !(1&a.wrap)||(((255&b)<<8)+(b>>8))%31) {
              t.msg='incorrect header check', a.mode=d; break;
            } if (8!=(15&b)) {
              t.msg='unknown compression method', a.mode=d; break;
            } if (m-=4, O=8+(15&(b>>>=4)), 0===a.wbits)a.wbits=O; else if (O>a.wbits) {
              t.msg='invalid window size', a.mode=d; break;
            }a.dmax=1<<O, t.adler=a.check=1, a.mode=512&b?10:l, b=0, m=0; break; case 2: for (;m<16;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          } if (a.flags=b, 8!=(255&a.flags)) {
              t.msg='unknown compression method', a.mode=d; break;
            } if (57344&a.flags) {
              t.msg='unknown header flags set', a.mode=d; break;
            }a.head&&(a.head.text=b>>8&1), 512&a.flags&&(F[0]=255&b, F[1]=b>>>8&255, a.check=i(a.check, F, 2, 0)), b=0, m=0, a.mode=3; case 3: for (;m<32;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          }a.head&&(a.head.time=b), 512&a.flags&&(F[0]=255&b, F[1]=b>>>8&255, F[2]=b>>>16&255, F[3]=b>>>24&255, a.check=i(a.check, F, 4, 0)), b=0, m=0, a.mode=4; case 4: for (;m<16;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          }a.head&&(a.head.xflags=255&b, a.head.os=b>>8), 512&a.flags&&(F[0]=255&b, F[1]=b>>>8&255, a.check=i(a.check, F, 2, 0)), b=0, m=0, a.mode=5; case 5: if (1024&a.flags) {
            for (;m<16;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            }a.length=b, a.head&&(a.head.extra_len=b), 512&a.flags&&(F[0]=255&b, F[1]=b>>>8&255, a.check=i(a.check, F, 2, 0)), b=0, m=0;
          } else a.head&&(a.head.extra=null); a.mode=6; case 6: if (1024&a.flags&&((z=a.length)>w&&(z=w), z&&(a.head&&(O=a.head.extra_len-a.length, a.head.extra||(a.head.extra=new Array(a.head.extra_len)), n.arraySet(a.head.extra, _, c, z, O)), 512&a.flags&&(a.check=i(a.check, _, z, c)), w-=z, c+=z, a.length-=z), a.length)) break t; a.length=0, a.mode=7; case 7: if (2048&a.flags) {
            if (0===w) break t; z=0; do {
              O=_[c+z++], a.head&&O&&a.length<65536&&(a.head.name+=String.fromCharCode(O));
            } while (O&&z<w); if (512&a.flags&&(a.check=i(a.check, _, z, c)), w-=z, c+=z, O) break t;
          } else a.head&&(a.head.name=null); a.length=0, a.mode=8; case 8: if (4096&a.flags) {
            if (0===w) break t; z=0; do {
              O=_[c+z++], a.head&&O&&a.length<65536&&(a.head.comment+=String.fromCharCode(O));
            } while (O&&z<w); if (512&a.flags&&(a.check=i(a.check, _, z, c)), w-=z, c+=z, O) break t;
          } else a.head&&(a.head.comment=null); a.mode=9; case 9: if (512&a.flags) {
            for (;m<16;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } if (b!==(65535&a.check)) {
              t.msg='header crc mismatch', a.mode=d; break;
            }b=0, m=0;
          }a.head&&(a.head.hcrc=a.flags>>9&1, a.head.done=!0), t.adler=a.check=0, a.mode=l; break; case 10: for (;m<32;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          }t.adler=a.check=f(b), b=0, m=0, a.mode=11; case 11: if (0===a.havedict) return t.next_out=g, t.avail_out=p, t.next_in=c, t.avail_in=w, a.hold=b, a.bits=m, 2; t.adler=a.check=1, a.mode=l; case l: if (5===e||6===e) break t; case 13: if (a.last) {
            b>>>=7&m, m-=7&m, a.mode=27; break;
          } for (;m<3;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } switch (a.last=1&b, m-=1, 3&(b>>>=1)) {
              case 0: a.mode=14; break; case 1: if (v(a), a.mode=20, 6===e) {
                b>>>=2, m-=2; break t;
              } break; case 2: a.mode=17; break; case 3: t.msg='invalid block type', a.mode=d;
            }b>>>=2, m-=2; break; case 14: for (b>>>=7&m, m-=7&m; m<32;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          } if ((65535&b)!=(b>>>16^65535)) {
              t.msg='invalid stored block lengths', a.mode=d; break;
            } if (a.length=65535&b, b=0, m=0, a.mode=15, 6===e) break t; case 15: a.mode=16; case 16: if (z=a.length) {
            if (z>w&&(z=w), z>p&&(z=p), 0===z) break t; n.arraySet(u, _, c, z, g), w-=z, c+=z, p-=z, g+=z, a.length-=z; break;
          }a.mode=l; break; case 17: for (;m<14;) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          } if (a.nlen=257+(31&b), b>>>=5, m-=5, a.ndist=1+(31&b), b>>>=5, m-=5, a.ncode=4+(15&b), b>>>=4, m-=4, a.nlen>286||a.ndist>30) {
              t.msg='too many length or distance symbols', a.mode=d; break;
            }a.have=0, a.mode=18; case 18: for (;a.have<a.ncode;) {
            for (;m<3;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            }a.lens[L[a.have++]]=7&b, b>>>=3, m-=3;
          } for (;a.have<19;)a.lens[L[a.have++]]=0; if (a.lencode=a.lendyn, a.lenbits=7, N={bits: a.lenbits}, T=o(0, a.lens, 0, 19, a.lencode, 0, a.work, N), a.lenbits=N.bits, T) {
              t.msg='invalid code lengths set', a.mode=d; break;
            }a.have=0, a.mode=19; case 19: for (;a.have<a.nlen+a.ndist;) {
            for (;E=(U=a.lencode[b&(1<<a.lenbits)-1])>>>16&255, I=65535&U, !((A=U>>>24)<=m);) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } if (I<16)b>>>=A, m-=A, a.lens[a.have++]=I; else {
              if (16===I) {
                for (R=A+2; m<R;) {
                  if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
                } if (b>>>=A, m-=A, 0===a.have) {
                  t.msg='invalid bit length repeat', a.mode=d; break;
                }O=a.lens[a.have-1], z=3+(3&b), b>>>=2, m-=2;
              } else if (17===I) {
                for (R=A+3; m<R;) {
                  if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
                }m-=A, O=0, z=3+(7&(b>>>=A)), b>>>=3, m-=3;
              } else {
                for (R=A+7; m<R;) {
                  if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
                }m-=A, O=0, z=11+(127&(b>>>=A)), b>>>=7, m-=7;
              } if (a.have+z>a.nlen+a.ndist) {
                t.msg='invalid bit length repeat', a.mode=d; break;
              } for (;z--;)a.lens[a.have++]=O;
            }
          } if (a.mode===d) break; if (0===a.lens[256]) {
              t.msg='invalid code -- missing end-of-block', a.mode=d; break;
            } if (a.lenbits=9, N={bits: a.lenbits}, T=o(1, a.lens, 0, a.nlen, a.lencode, 0, a.work, N), a.lenbits=N.bits, T) {
              t.msg='invalid literal/lengths set', a.mode=d; break;
            } if (a.distbits=6, a.distcode=a.distdyn, N={bits: a.distbits}, T=o(2, a.lens, a.nlen, a.ndist, a.distcode, 0, a.work, N), a.distbits=N.bits, T) {
              t.msg='invalid distances set', a.mode=d; break;
            } if (a.mode=20, 6===e) break t; case 20: a.mode=21; case 21: if (w>=6&&p>=258) {
            t.next_out=g, t.avail_out=p, t.next_in=c, t.avail_in=w, a.hold=b, a.bits=m, s(t, x), g=t.next_out, u=t.output, p=t.avail_out, c=t.next_in, _=t.input, w=t.avail_in, b=a.hold, m=a.bits, a.mode===l&&(a.back=-1); break;
          } for (a.back=0; E=(U=a.lencode[b&(1<<a.lenbits)-1])>>>16&255, I=65535&U, !((A=U>>>24)<=m);) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } if (E&&0==(240&E)) {
              for (Z=A, C=E, D=I; E=(U=a.lencode[D+((b&(1<<Z+C)-1)>>Z)])>>>16&255, I=65535&U, !(Z+(A=U>>>24)<=m);) {
                if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
              }b>>>=Z, m-=Z, a.back+=Z;
            } if (b>>>=A, m-=A, a.back+=A, a.length=I, 0===E) {
              a.mode=26; break;
            } if (32&E) {
              a.back=-1, a.mode=l; break;
            } if (64&E) {
              t.msg='invalid literal/length code', a.mode=d; break;
            }a.extra=15&E, a.mode=22; case 22: if (a.extra) {
            for (R=a.extra; m<R;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            }a.length+=b&(1<<a.extra)-1, b>>>=a.extra, m-=a.extra, a.back+=a.extra;
          }a.was=a.length, a.mode=23; case 23: for (;E=(U=a.distcode[b&(1<<a.distbits)-1])>>>16&255, I=65535&U, !((A=U>>>24)<=m);) {
            if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
          } if (0==(240&E)) {
              for (Z=A, C=E, D=I; E=(U=a.distcode[D+((b&(1<<Z+C)-1)>>Z)])>>>16&255, I=65535&U, !(Z+(A=U>>>24)<=m);) {
                if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
              }b>>>=Z, m-=Z, a.back+=Z;
            } if (b>>>=A, m-=A, a.back+=A, 64&E) {
              t.msg='invalid distance code', a.mode=d; break;
            }a.offset=I, a.extra=15&E, a.mode=24; case 24: if (a.extra) {
            for (R=a.extra; m<R;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            }a.offset+=b&(1<<a.extra)-1, b>>>=a.extra, m-=a.extra, a.back+=a.extra;
          } if (a.offset>a.dmax) {
              t.msg='invalid distance too far back', a.mode=d; break;
            }a.mode=25; case 25: if (0===p) break t; if (z=x-p, a.offset>z) {
            if ((z=a.offset-z)>a.whave&&a.sane) {
              t.msg='invalid distance too far back', a.mode=d; break;
            }z>a.wnext?(z-=a.wnext, S=a.wsize-z):S=a.wnext-z, z>a.length&&(z=a.length), B=a.window;
          } else B=u, S=g-a.offset, z=a.length; z>p&&(z=p), p-=z, a.length-=z; do {
              u[g++]=B[S++];
            } while (--z); 0===a.length&&(a.mode=21); break; case 26: if (0===p) break t; u[g++]=a.length, p--, a.mode=21; break; case 27: if (a.wrap) {
            for (;m<32;) {
              if (0===w) break t; w--, b|=_[c++]<<m, m+=8;
            } if (x-=p, t.total_out+=x, a.total+=x, x&&(t.adler=a.check=a.flags?i(a.check, u, x, g-x):r(a.check, u, x, g-x)), x=p, (a.flags?b:f(b))!==a.check) {
              t.msg='incorrect data check', a.mode=d; break;
            }b=0, m=0;
          }a.mode=28; case 28: if (a.wrap&&a.flags) {
            for (;m<32;) {
              if (0===w) break t; w--, b+=_[c++]<<m, m+=8;
            } if (b!==(4294967295&a.total)) {
              t.msg='incorrect length check', a.mode=d; break;
            }b=0, m=0;
          }a.mode=29; case 29: T=1; break t; case d: T=-3; break t; case 31: return -4; default: return h;
        }
      } return t.next_out=g, t.avail_out=p, t.next_in=c, t.avail_in=w, a.hold=b, a.bits=m, (a.wsize||x!==t.avail_out&&a.mode<d&&(a.mode<27||4!==e))&&k(t, t.output, t.next_out, x-t.avail_out)?(a.mode=31, -4):(y-=t.avail_in, x-=t.avail_out, t.total_in+=y, t.total_out+=x, a.total+=x, a.wrap&&x&&(t.adler=a.check=a.flags?i(a.check, u, x, t.next_out-x):r(a.check, u, x, t.next_out-x)), t.data_type=a.bits+(a.last?64:0)+(a.mode===l?128:0)+(20===a.mode||15===a.mode?256:0), (0===y&&0===x||4===e)&&0===T&&(T=-5), T);
    }, e.inflateEnd=function(t) {
      if (!t||!t.state) return h; const e=t.state; return e.window&&(e.window=null), t.state=null, 0;
    }, e.inflateGetHeader=function(t, e) {
      let a; return t&&t.state?0==(2&(a=t.state).wrap)?h:(a.head=e, e.done=!1, 0):h;
    }, e.inflateSetDictionary=function(t, e) {
      let a; const n=e.length; return t&&t.state?0!==(a=t.state).wrap&&11!==a.mode?h:11===a.mode&&r(1, e, n, 0)!==a.check?-3:k(t, e, n, n)?(a.mode=31, -4):(a.havedict=1, 0):h;
    }, e.inflateInfo='pako inflate (from Nodeca project)';
  }, 241: (t, e, a)=>{
    const n=a(236); const r=[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]; const i=[16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]; const s=[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]; const o=[16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports=function(t, e, a, h, l, d, f, _) {
      let u; let c; let g; let w; let p; let b; let m; let v; let k; const y=_.bits; let x=0; let z=0; let S=0; let B=0; let A=0; let E=0; let I=0; let Z=0; let C=0; let D=0; let O=null; let T=0; const N=new n.Buf16(16); const R=new n.Buf16(16); let U=null; let F=0; for (x=0; x<=15; x++)N[x]=0; for (z=0; z<h; z++)N[e[a+z]]++; for (A=y, B=15; B>=1&&0===N[B]; B--);if (A>B&&(A=B), 0===B) return l[d++]=20971520, l[d++]=20971520, _.bits=1, 0; for (S=1; S<B&&0===N[S]; S++);for (A<S&&(A=S), Z=1, x=1; x<=15; x++) if (Z<<=1, (Z-=N[x])<0) return -1; if (Z>0&&(0===t||1!==B)) return -1; for (R[1]=0, x=1; x<15; x++)R[x+1]=R[x]+N[x]; for (z=0; z<h; z++)0!==e[a+z]&&(f[R[e[a+z]]++]=z); if (0===t?(O=U=f, b=19):1===t?(O=r, T-=257, U=i, F-=257, b=256):(O=s, U=o, b=-1), D=0, z=0, x=S, p=d, E=A, I=0, g=-1, w=(C=1<<A)-1, 1===t&&C>852||2===t&&C>592) return 1; for (;;) {
        m=x-I, f[z]<b?(v=0, k=f[z]):f[z]>b?(v=U[F+f[z]], k=O[T+f[z]]):(v=96, k=0), u=1<<x-I, S=c=1<<E; do {
          l[p+(D>>I)+(c-=u)]=m<<24|v<<16|k|0;
        } while (0!==c); for (u=1<<x-1; D&u;)u>>=1; if (0!==u?(D&=u-1, D+=u):D=0, z++, 0==--N[x]) {
          if (x===B) break; x=e[a+f[z]];
        } if (x>A&&(D&w)!==g) {
          for (0===I&&(I=A), p+=S, Z=1<<(E=x-I); E+I<B&&!((Z-=N[E+I])<=0);)E++, Z<<=1; if (C+=1<<E, 1===t&&C>852||2===t&&C>592) return 1; l[g=D&w]=A<<24|E<<16|p-d|0;
        }
      } return 0!==D&&(l[p+D]=x-I<<24|64<<16|0), _.bits=A, 0;
    };
  }, 898: (t)=>{
    t.exports={'2': 'need dictionary', '1': 'stream end', '0': '', '-1': 'file error', '-2': 'stream error', '-3': 'data error', '-4': 'insufficient memory', '-5': 'buffer error', '-6': 'incompatible version'};
  }, 342: (t, e, a)=>{
    const n=a(236); function r(t) {
      for (let e=t.length; --e>=0;)t[e]=0;
    } const i=[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; const s=[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; const o=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]; const h=[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; const l=new Array(576); r(l); const d=new Array(60); r(d); const f=new Array(512); r(f); const _=new Array(256); r(_); const u=new Array(29); r(u); let c; let g; let w; const p=new Array(30); function b(t, e, a, n, r) {
      this.static_tree=t, this.extra_bits=e, this.extra_base=a, this.elems=n, this.max_length=r, this.has_stree=t&&t.length;
    } function m(t, e) {
      this.dyn_tree=t, this.max_code=0, this.stat_desc=e;
    } function v(t) {
      return t<256?f[t]:f[256+(t>>>7)];
    } function k(t, e) {
      t.pending_buf[t.pending++]=255&e, t.pending_buf[t.pending++]=e>>>8&255;
    } function y(t, e, a) {
t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535, k(t, t.bi_buf), t.bi_buf=e>>16-t.bi_valid, t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535, t.bi_valid+=a);
    } function x(t, e, a) {
      y(t, a[2*e], a[2*e+1]);
    } function z(t, e) {
      let a=0; do {
        a|=1&t, t>>>=1, a<<=1;
      } while (--e>0); return a>>>1;
    } function S(t, e, a) {
      let n; let r; const i=new Array(16); let s=0; for (n=1; n<=15; n++)i[n]=s=s+a[n-1]<<1; for (r=0; r<=e; r++) {
        const o=t[2*r+1]; 0!==o&&(t[2*r]=z(i[o]++, o));
      }
    } function B(t) {
      let e; for (e=0; e<286; e++)t.dyn_ltree[2*e]=0; for (e=0; e<30; e++)t.dyn_dtree[2*e]=0; for (e=0; e<19; e++)t.bl_tree[2*e]=0; t.dyn_ltree[512]=1, t.opt_len=t.static_len=0, t.last_lit=t.matches=0;
    } function A(t) {
t.bi_valid>8?k(t, t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf), t.bi_buf=0, t.bi_valid=0;
    } function E(t, e, a, n) {
      const r=2*e; const i=2*a; return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a];
    } function I(t, e, a) {
      for (var n=t.heap[a], r=a<<1; r<=t.heap_len&&(r<t.heap_len&&E(e, t.heap[r+1], t.heap[r], t.depth)&&r++, !E(e, n, t.heap[r], t.depth));)t.heap[a]=t.heap[r], a=r, r<<=1; t.heap[a]=n;
    } function Z(t, e, a) {
      let n; let r; let o; let h; let l=0; if (0!==t.last_lit) {
        do {
          n=t.pending_buf[t.d_buf+2*l]<<8|t.pending_buf[t.d_buf+2*l+1], r=t.pending_buf[t.l_buf+l], l++, 0===n?x(t, r, e):(x(t, (o=_[r])+256+1, e), 0!==(h=i[o])&&y(t, r-=u[o], h), x(t, o=v(--n), a), 0!==(h=s[o])&&y(t, n-=p[o], h));
        } while (l<t.last_lit);
      } x(t, 256, e);
    } function C(t, e) {
      let a; let n; let r; const i=e.dyn_tree; const s=e.stat_desc.static_tree; const o=e.stat_desc.has_stree; const h=e.stat_desc.elems; let l=-1; for (t.heap_len=0, t.heap_max=573, a=0; a<h; a++)0!==i[2*a]?(t.heap[++t.heap_len]=l=a, t.depth[a]=0):i[2*a+1]=0; for (;t.heap_len<2;)i[2*(r=t.heap[++t.heap_len]=l<2?++l:0)]=1, t.depth[r]=0, t.opt_len--, o&&(t.static_len-=s[2*r+1]); for (e.max_code=l, a=t.heap_len>>1; a>=1; a--)I(t, i, a); r=h; do {
        a=t.heap[1], t.heap[1]=t.heap[t.heap_len--], I(t, i, 1), n=t.heap[1], t.heap[--t.heap_max]=a, t.heap[--t.heap_max]=n, i[2*r]=i[2*a]+i[2*n], t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1, i[2*a+1]=i[2*n+1]=r, t.heap[1]=r++, I(t, i, 1);
      } while (t.heap_len>=2); t.heap[--t.heap_max]=t.heap[1], function(t, e) {
        let a; let n; let r; let i; let s; let o; const h=e.dyn_tree; const l=e.max_code; const d=e.stat_desc.static_tree; const f=e.stat_desc.has_stree; const _=e.stat_desc.extra_bits; const u=e.stat_desc.extra_base; const c=e.stat_desc.max_length; let g=0; for (i=0; i<=15; i++)t.bl_count[i]=0; for (h[2*t.heap[t.heap_max]+1]=0, a=t.heap_max+1; a<573; a++)(i=h[2*h[2*(n=t.heap[a])+1]+1]+1)>c&&(i=c, g++), h[2*n+1]=i, n>l||(t.bl_count[i]++, s=0, n>=u&&(s=_[n-u]), o=h[2*n], t.opt_len+=o*(i+s), f&&(t.static_len+=o*(d[2*n+1]+s))); if (0!==g) {
          do {
            for (i=c-1; 0===t.bl_count[i];)i--; t.bl_count[i]--, t.bl_count[i+1]+=2, t.bl_count[c]--, g-=2;
          } while (g>0); for (i=c; 0!==i; i--) for (n=t.bl_count[i]; 0!==n;)(r=t.heap[--a])>l||(h[2*r+1]!==i&&(t.opt_len+=(i-h[2*r+1])*h[2*r], h[2*r+1]=i), n--);
        }
      }(t, e), S(i, l, t.bl_count);
    } function D(t, e, a) {
      let n; let r; let i=-1; let s=e[1]; let o=0; let h=7; let l=4; for (0===s&&(h=138, l=3), e[2*(a+1)+1]=65535, n=0; n<=a; n++)r=s, s=e[2*(n+1)+1], ++o<h&&r===s||(o<l?t.bl_tree[2*r]+=o:0!==r?(r!==i&&t.bl_tree[2*r]++, t.bl_tree[32]++):o<=10?t.bl_tree[34]++:t.bl_tree[36]++, o=0, i=r, 0===s?(h=138, l=3):r===s?(h=6, l=3):(h=7, l=4));
    } function O(t, e, a) {
      let n; let r; let i=-1; let s=e[1]; let o=0; let h=7; let l=4; for (0===s&&(h=138, l=3), n=0; n<=a; n++) {
        if (r=s, s=e[2*(n+1)+1], !(++o<h&&r===s)) {
          if (o<l) {
            do {
              x(t, r, t.bl_tree);
            } while (0!=--o);
          } else 0!==r?(r!==i&&(x(t, r, t.bl_tree), o--), x(t, 16, t.bl_tree), y(t, o-3, 2)):o<=10?(x(t, 17, t.bl_tree), y(t, o-3, 3)):(x(t, 18, t.bl_tree), y(t, o-11, 7)); o=0, i=r, 0===s?(h=138, l=3):r===s?(h=6, l=3):(h=7, l=4);
        }
      }
    }r(p); let T=!1; function N(t, e, a, r) {
      y(t, 0+(r?1:0), 3), function(t, e, a, r) {
        A(t), k(t, a), k(t, ~a), n.arraySet(t.pending_buf, t.window, e, a, t.pending), t.pending+=a;
      }(t, e, a);
    }e._tr_init=function(t) {
      T||(function() {
        let t; let e; let a; let n; let r; const h=new Array(16); for (a=0, n=0; n<28; n++) for (u[n]=a, t=0; t<1<<i[n]; t++)_[a++]=n; for (_[a-1]=n, r=0, n=0; n<16; n++) for (p[n]=r, t=0; t<1<<s[n]; t++)f[r++]=n; for (r>>=7; n<30; n++) for (p[n]=r<<7, t=0; t<1<<s[n]-7; t++)f[256+r++]=n; for (e=0; e<=15; e++)h[e]=0; for (t=0; t<=143;)l[2*t+1]=8, t++, h[8]++; for (;t<=255;)l[2*t+1]=9, t++, h[9]++; for (;t<=279;)l[2*t+1]=7, t++, h[7]++; for (;t<=287;)l[2*t+1]=8, t++, h[8]++; for (S(l, 287, h), t=0; t<30; t++)d[2*t+1]=5, d[2*t]=z(t, 5); c=new b(l, i, 257, 286, 15), g=new b(d, s, 0, 30, 15), w=new b(new Array(0), o, 0, 19, 7);
      }(), T=!0), t.l_desc=new m(t.dyn_ltree, c), t.d_desc=new m(t.dyn_dtree, g), t.bl_desc=new m(t.bl_tree, w), t.bi_buf=0, t.bi_valid=0, B(t);
    }, e._tr_stored_block=N, e._tr_flush_block=function(t, e, a, n) {
      let r; let i; let s=0; t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t) {
        let e; let a=4093624447; for (e=0; e<=31; e++, a>>>=1) if (1&a&&0!==t.dyn_ltree[2*e]) return 0; if (0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26]) return 1; for (e=32; e<256; e++) if (0!==t.dyn_ltree[2*e]) return 1; return 0;
      }(t)), C(t, t.l_desc), C(t, t.d_desc), s=function(t) {
        let e; for (D(t, t.dyn_ltree, t.l_desc.max_code), D(t, t.dyn_dtree, t.d_desc.max_code), C(t, t.bl_desc), e=18; e>=3&&0===t.bl_tree[2*h[e]+1]; e--);return t.opt_len+=3*(e+1)+5+5+4, e;
      }(t), r=t.opt_len+3+7>>>3, (i=t.static_len+3+7>>>3)<=r&&(r=i)):r=i=a+5, a+4<=r&&-1!==e?N(t, e, a, n):4===t.strategy||i===r?(y(t, 2+(n?1:0), 3), Z(t, l, d)):(y(t, 4+(n?1:0), 3), function(t, e, a, n) {
        let r; for (y(t, e-257, 5), y(t, a-1, 5), y(t, n-4, 4), r=0; r<n; r++)y(t, t.bl_tree[2*h[r]+1], 3); O(t, t.dyn_ltree, e-1), O(t, t.dyn_dtree, a-1);
      }(t, t.l_desc.max_code+1, t.d_desc.max_code+1, s+1), Z(t, t.dyn_ltree, t.dyn_dtree)), B(t), n&&A(t);
    }, e._tr_tally=function(t, e, a) {
      return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255, t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e, t.pending_buf[t.l_buf+t.last_lit]=255&a, t.last_lit++, 0===e?t.dyn_ltree[2*a]++:(t.matches++, e--, t.dyn_ltree[2*(_[a]+256+1)]++, t.dyn_dtree[2*v(e)]++), t.last_lit===t.lit_bufsize-1;
    }, e._tr_align=function(t) {
      y(t, 2, 3), x(t, 256, l), function(t) {
16===t.bi_valid?(k(t, t.bi_buf), t.bi_buf=0, t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf, t.bi_buf>>=8, t.bi_valid-=8);
      }(t);
    };
  }, 292: (t)=>{
    t.exports=function() {
      this.input=null, this.next_in=0, this.avail_in=0, this.total_in=0, this.output=null, this.next_out=0, this.avail_out=0, this.total_out=0, this.msg='', this.state=null, this.data_type=2, this.adler=0;
    };
  }}; const e={}; function a(n) {
    const r=e[n]; if (void 0!==r) return r.exports; const i=e[n]={exports: {}}; return t[n](i, i.exports, a), i.exports;
  }a.d=(t, e)=>{
    for (const n in e)a.o(e, n)&&!a.o(t, n)&&Object.defineProperty(t, n, {enumerable: !0, get: e[n]});
  }, a.o=(t, e)=>Object.prototype.hasOwnProperty.call(t, e), a.r=(t)=>{
    'undefined'!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t, Symbol.toStringTag, {value: 'Module'}), Object.defineProperty(t, '__esModule', {value: !0});
  }; const n={}; (()=>{
    a.r(n), a.d(n, {read: ()=>e}); const t=a(591); function e(e) {
      function a(e, n) {
        let o; let h; let l; const d=new DataView(e); let f=!1; d.getInt32(n, s)>>>16==0&&(f=!0), f?(o=d.getInt32(n, s), h=d.getInt32(n+4, s), l=8):(o=d.getInt16(n, s), h=d.getInt16(n+2, s), l=4); let _; const u={type: o, length: (_=h+l, _%8==0?_:_+(8-_%8))}; switch (o) {
          case 1: for (var g=[], w=0; w<h; w++)g.push(d.getInt8(n+l+w)); return u.data=g, u; case 2: for (g=[], w=0; w<h; w++)g.push(d.getUint8(n+l+w)); return u.data=g, u; case 3: for (g=[], w=0; w<h/2; w++)g.push(d.getInt16(n+l+2*w, s)); return u.data=g, u; case 4: for (g=[], w=0; w<h/2; w++)g.push(d.getUint16(n+l+2*w, s)); return u.data=g, u; case 5: for (g=[], w=0; w<h/4; w++)g.push(d.getInt32(n+l+4*w, s)); return u.data=g, u; case 6: for (g=[], w=0; w<h/4; w++)g.push(d.getUint32(n+l+4*w, s)); return u.data=g, u; case 7: for (g=[], w=0; w<h/4; w++)g.push(d.getFloat32(n+l+4*w, s)); return u.data=g, u; case 8: throw new r(e, n, 'Data element\'s type is 8, \'Reserved\' (unknown)'); case 9: for (g=[], w=0; w<h/8; w++)g.push(d.getFloat64(n+l+8*w, s)); return u.data=g, u; case 10: throw new r(e, n, 'Data element\'s type is 10, \'Reserved\' (unknown)'); case 11: throw new r(e, n, 'Data element\'s type is 11, \'Reserved\' (unknown)'); case 12: throw new i(e, n, 'INT64', 'Data element\'s type is 12, \'INT64\' (unsupported)'); case 13: throw new i(e, n, 'UINT64', 'Data element\'s type is 13, \'UINT64\' (unsupported)'); case 14: var p=n+l; if (s) var b=d.getInt8(p+9)>>3&1, m=d.getInt8(p+8); else b=d.getInt8(p+10)>>3&1, m=d.getInt8(p+11); var v=a(e, p+=16); p+=v.length, 2==v.data.length&&(1==v.data[0]?v.data=[v.data[1]]:1==v.data[1]&&(v.data=[v.data[0]])); var k; var y=''; var x=a(e, p); for (w=0; w<x.data.length; w++)y+=String.fromCharCode(x.data[w]); function j(t, e) {
            for (var a=0, n=[], r=0; r<t.length; r++)n.push(0); return function t(r, i) {
              for (var s=[], o=0; r[i]>o; o++)i==r.length-1?(s.push(e[c(n, r)]), n[a]++):(a++, s.push(t(r, i+1)), n[a]=0, a--, n[a]++); return s;
            }(t, 0);
          } switch (p+=x.length, m) {
              case 1: var z=[]; var S=0; for (w=0; w<v.data.length; w++)w?S*=v.data[w]:S=v.data[w]; for (w=0; w<S; w++) {
                const B=a(e, p); z.push(B.data), p+=B.length;
              }k=j(v.data, z); break; case 2: k={}; var A=a(e, p); var E=a(e, p+=A.length); p+=E.length; var I=[]; for (w=0; w<E.data.length/A.data[0]; w++) {
                I.push(''); for (var Z=0; 0!=E.data[Z+w*A.data[0]]&&Z<A.data[0]; Z++)I[w]+=String.fromCharCode(E.data[Z+w*A.data[0]]);
              } if (1!=v.data[0]||v.data.length>1) {
                  for (z=[], S=0, w=0; w<v.data.length; w++)w?S*=v.data[w]:S=v.data[w]; for (w=0; w<S; w++) {
                    const C={}; for (Z=0; Z<I.length; Z++)p+=(D=a(e, p)).length, C[I[Z]]=D.data; z.push(C);
                  }k=j(v.data, z);
                } else {
                  for (w=0; w<I.length; w++) {
                    var D; p+=(D=a(e, p)).length, k[I[w]]=D.data;
                  }
                } break; case 3: throw new i(e, n, 'OBJECT', 'Array\'s type is 3, \'mxOBJECT_CLASS\' (unsupported)'); case 4: p+=(z=a(e, p)).length, k=v.data.length>1?j(v.data, z.data):z.data; break; case 5: var O; var T=a(e, p); var N=a(e, p+=T.length); if (p+=N.length, p+=(R=a(e, p)).length, b) for (p+=(U=a(e, p)).length, O=[], w=0; w<T.data.length; w++)O.push({r: R.data[w], i: U.data[w]}); else O=R.data; if (2!=v.data.length) throw new r(e, n, 'MATLAB only supports two dimensional sparse arrays, while this sparse array is '+v.data.length+' dimensional'); for (k={x: v.data[1], y: v.data[0], nz: []}, w=0; w<N.data.length-1; w++) for (Z=N.data[w]; Z<N.data[w+1]; Z++)k.nz.push({x: w, y: T.data[Z], v: O[Z]}); break; case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: var R; var U; if (z=[], b) for (p+=(R=a(e, p)).length, p+=(U=a(e, p)).length, w=0; w<R.data.length; w++)z.push({r: R.data[w], i: U.data[w]}); else p+=(R=a(e, p)).length, z=R.data; k=j(v.data, z); break; case 14: throw new i(e, n, 'INT64', 'Array\'s type is 14, \'mxINT64_CLASS\' (unsupported)'); case 15: throw new i(e, n, 'UINT64', 'Array\'s type is 15, \'mxUINT64_CLASS\' (unsupported)'); case 16: case 17: return u; default: throw new r(e, n, 'Array\'s type is '+m+' (unknown)');
            } return u.name=y, u.data=k, u; case 15: var F=new Uint8Array(e.slice(n+l, n+l+h)); var L=a(t.inflate(F).buffer, 0); return L.hasOwnProperty('data')&&(u.data=L.data), L.hasOwnProperty('name')&&(u.name=L.name), u.length=h+l, u; case 16: for (g='', w=0; w<h; w++)g+=String.fromCodePoint(d.getInt8(n+l+w)); return u.data=g, u; case 17: for (g='', w=0; w<h; w++)g+=String.fromCodePoint(d.getInt16(n+l+w, s)); return u.data=g, u; case 18: for (g='', w=0; w<h; w++)g+=String.fromCodePoint(d.getInt32(n+l+w, s)); return u.data=g, u; default: throw new r(e, n, 'Data element\'s type is '+o+' (unknown)');
        }
      } const n=new DataView(e); var s=!0; const o=n.getInt16(126, s); if (18765==o)s=!1; else if (19785!=o) throw new r(e, 126, 'Expected 0x4D49 for big endian or 0x494D for little endian, but got '+o); const h=n.getInt16(124, s); switch (h) {
        case 256: break; case 512: throw new i(e, 124, 'HDF5', 'Matlab v7.3 MAT-files are not supported'); default: throw new r(e, 124, 'Version identifier '+h+' unknown');
      } for (var l='', d=0; d<116; d++)l+=String.fromCharCode(n.getInt8(d)); for (var f={header: l, data: {}}, _=128; _<e.byteLength;) {
        const u=a(e, _); u.hasOwnProperty('name')&&(f.data[u.name]=u.data), _+=u.length;
      } return f; function c(t, e) {
        for (var a=t[0], n=1; n<e.length; n++)a+=t[n]*e[n-1]; return a;
      }
    } class r extends Error {
      constructor(t, e, a) {
        super('Unexpected value when reading near byte '+e+': '+a), this.name='FormatError', this.data=t, this.byte=e;
      }
    } class i extends Error {
      constructor(t, e, a, n) {
        super('The MAT file has features that are not supported. See Limitations on the project\'s page: '+n), this.name='FeatureError', this.data=t, this.byte=e, this.feature=a;
      }
    }
  })(), mat4js=n;
})();
